// =============================================================================
// GENERADOR DE CODI DE LOOS ===================================================
// =============================================================================
/*
================================================================================
Conceptes:
Posicio:
    - Etiqueta
    - Int (b+desp)
    - DespCamp(Desp)
    - RefParametre(Desp)
    
Adreca:
    - RefEtiqueta
    - vector
    - queue
    - AdrecaAPila
================================================================================
*/

use COM
use semantic
use GenCod
use queue

// =============================================================================
// Identificaci� dels alumnes del grup =========================================
// =============================================================================

SetComponentsGrup([
    // Una linea per alumne amb el format "nom","cognoms","nia","e-mail")
   //("nom","cognoms","0000000","0000000@uab.cat")
   ("Oriol","Feliu Juarez","1492319","1492319@uab.cat")
])

// =============================================================================
// Opciones Informes ===========================================================
// =============================================================================

SetOpcionesInformes(
    VerSintactico=>true,
    VerSemantico=>true,
    VerGenCod=>false,
    VerObligatorio=>true,
    VerAdicional=>true,
    VerCorrecto=>false,
	VerExtensions=>["ArrayRangos", 
    "DeclaracionMultiplesParametros", 
    "DeclaracionVariableAuto", 
    "InstruccionBreak",
    "InstruccionForTo",
    "InstruccionRepeatUntil", 
    "OperadorMin", 
    "OperadorPow"] // ["extension1", "extensio2",...] nomes corretgir les extensions indicades
); 

// =============================================================================
// PARAMETRES ==================================================================
// =============================================================================

proc ComprovarPermisosParametres(dvParametres:List,Parametres:List)=>
{
    for (dvp<-reverse(dvParametres),p<-reverse(Parametres)) {
        if (p.Referencia && !dvp.PermisEscriptura) throw Exception("No es pot escriure parametre per referencia ", p.Nom);
    }
}

// ================================================================================
// CONSTRUCCIO OBJECTES ===========================================================
// ================================================================================

// ComprovarConstruible =========================================================

Proc t:TipusDeDades.ComprovarConstruible(dvParametres)=>
{
    var Constructors=t.Constructors();
    if (Constructors==[]) {
        if (dvParametres==[]) return; // No hi ha construcci�
        if (dvParametres.Length>1) throw SemanticError("No hi ha constructor pel tipus de dades ",t," amb ", dvParametres.Length," parametres");
        if (!TipusElementP(dvParametres.Head.Tipus,t)) throw SemanticError("No hi ha constructor pel tipus de dades ",t," amb ", dvParametres.Head.Tipus);
   }
    else {
        var etsConstructor=SeleccionarMetode(Constructors,dvParametres);        
        ComprovarPermisosParametres(dvParametres,etsConstructor.Parametres);
    }
}

// GRAMATICA ===================================================================

Proc Compila(FileName:String,St=Unbound,VeureCodiGenerat=false,VeureCodiExecucio=false)=>
{
    ParserErrorNLin=Unbound;
    ParserErrorLine=Unbound;
    ParserErrorNCol=Unbound;
    ParserErrorException=unbound;
    Var OldScanInput=ScanInput;
    if (TypeP(stream,St)) ScanInput=St;
    else ScanInput=Open(FileName,SMIn,[],SourcePaths);
    cout.PrintLN("--------------------------------------------------------");
    cout.PrintLN("Analitzant ",FileName);
    cout.flush();
    Var Oldline=system$CSLGetScanLineNumber();
    Var OldNLin=system$CSLGetParserLineNumber();
    system$CSLSetScanLineNumber(1);
    SortidaSemantic=OutStrStream();
    TRY {
    BNF_PARSER <programa()>
    TERMINALS
        + - * / identificador numero caracter string ( ) =
        == != > < >= <= ^
        ! && || 
        , ; : . & "::"
        Type var Const Function Procedure constructor destructor
        Integer Real Character bool class array of "[" "]" "{" "}"
        if then else while do return
        Print PrintLn Exit
        delete new
        true false null this operator
        IMPRIMIR_TAULA_DE_SIMBOLS
        // AFEGITS
        break repeat until for to ".." min **
        /////////
    BNF
    // <Programa> ==============================================================
    Rule <programa>::=
        @TS=TaulaSimbols();
        {
            <DecFun>
            | <DecProc>
            | <DecConstructor>
            | <DecDestructor>
            | <DecVar>
            | <DecTipus>
            | <DecClasse>
            | IMPRIMIR_TAULA_DE_SIMBOLS ";" @ts.Imprimir(); @ts.ImprimirSemantic(SortidaSemantic);
        }
		@VerifyEOFReached();
        @{
            Var EtssMain=TS.Buscar("main");
            if (!-](EtsMain<-EtssMain,TypeP(ETSFuncio,EtsMain) && EtsMain.TipusRetorn=:=TVoid && EtsMain.Parametres==[])) 
                throw SemanticError("Falta declarar el procediment Main o se ha declarado incorrectamente");
        }
        
    // <DecTipus> ==============================================================
    Rule <DecTipus>::= @var nom,ets;
        "Type" identificador#(nom)
        @TS.ComprovarDuplicat(nom);
        @ets=ETSTipus(nom,Unbound);
        @TS.Insertar(ets);
        = <tipus(ets.Tipus,nom)> ";"
        
    // <Tipus> =================================================================
    Rule <tipus(&t,NomRec)>::=
        (
            Integer @t=TInt;
            | Real @t=TReal;
            | Character @t=TChar;
            | Bool @t=TBool;
            | @t=TApuntador(Unbound);
              ^ <tipus(t.TipusBase,Unbound)>
            /*| @var sz;
              Array "[" 
              numero#(sz)
              @if (!TypeP(Int,sz)) throw SemanticError("Mida d'array err�nia");       
              @if (sz<=0) throw SemanticError("Mida d'array err�nia");
              "]" of
              @t=TArray(sz,Unbound);
              <tipus(t.TipusElements,NomRec)>*/
            |   @var sz1;
                @var sz2;
                @var range = false;
                Array "["
                ["-"]numero#(sz1) 
                [ 
                    ".." ["-"]numero#(sz2) 
                    @range = true; 
                ] // es vector
                @if (!TypeP(Int,sz1) || sz1 <= 0) throw SemanticError("Mida d'array erronia");  
                @if (range && (!TypeP(Int,sz2) || sz2 <= 0)) throw SemanticError("Mida d'array erronia");  
                "]" of 

                @{
                    if(range) 
                        t=TArray((sz1, sz2),Unbound);
                    else
                        t=TArray(sz1,Unbound);
                }
                <tipus(t.TipusElements,NomRec)>
            | @var nom;
              identificador#(nom)
               @{
                   var ets=TS.Buscar(nom).Head;
                   if (!TypeP(ETSTipus,ets))
                        throw SemanticError(nom," no �s un tipus de dades");
                   if (ets.Nom==NomRec)
                        throw SemanticError("Declaraci� recursiva del tipus de dades ",nom);
                   t=ets.Tipus;
               }
        )
        @AssociarAtribut("Tipus=",TS.NomTipus(t));

    // <DecClasse> =============================================================
    Rule <DecClasse>::=@var nom,base=TVoid;      
        "Class" Identificador#(nom)
        @TS.ComprovarDuplicat(nom);
        [
            @var nomBase;
            ":" Identificador#(nomBase) 
            @base=TS.BuscarClasse(nomBase);
        ]
        @var classe=TClasse(base);
        @var ets=ETSTipus(nom,classe);
        @TS.Insertar(ets);
        @TS.NouAmbit(ets.Tipus);
        "{" { <ElementClasse(classe,nom)> } "}"
        @TS.EliminarAmbit();
        @{
            classe.membres=reverse(classe.membres);
            // CREACIO PER COMPATIBILITAT AMB EL CORRECTOR DE GENERACIO DE CODI
            // NO NECESSARI PER SEMANTIC
            // Creaci�n del constructor por defecto i per copia ----------------
            var ETSCreades=[];
            if (classe.Constructors()=:=[]) {
                if ((classe.Base.Constructors()!:=[]) ||
                    -](ets<-classe.membres,
                    TypeP(ETSVariable,ets),
                    ets.Tipus.Constructors()!:=[])) {
                    // Crear el constructor per defecte
                    try {
                        classe.ComprovarConstruiblePerDefecte();
                        var ETSConstructor=ETSFuncio(TFConstructor,nom,classe,[],TVoid);
                        ETSConstructor.TeCos=true;
                        ETSCreades=ETSConstructor::ETSCreades;
                    }
                    catch (ex) {}
                    // Crear el constructor per copia
                    try {
                        classe.ComprovarConstruiblePerCopia();
                        var ETSConstructor=ETSFuncio(TFConstructor,nom,classe,[Parametre("Font",classe,true,false,false)],TVoid);
                        ETSConstructor.TeCos=true;
                        ETSCreades=ETSConstructor::ETSCreades;
                    }
                    catch (ex) {}
                }
            }
            // Crear assignador per defecte ------------------------------------
            if (classe.Constructors()=:=[]) {                
                if (classe.Base.AssignadorDefinitP() || 
                    -](ets<-classe.membres, TypeP(ETSVariable,ets), ets.Tipus.AssignadorDefinitP())) {
                    // Crear el assignador 
                    try {
                        classe.ComprovarAssignable();
                        var ETSAsignador=ETSFuncio(TFProcediment,"operator=",classe,[Parametre("Font",classe,true,false,false)],TVoid);
                        ETSCreades=ETSAsignador::ETSCreades;
                        ETSAsignador.TeCos=true;
                        //classe.Insertar(ETSAsignador);        
                    }
                    catch (ex) {}
                }
            }
            for (ets<-reverse(ETSCreades)) classe.Insertar(ets);
            // Crear destructor por defecto ------------------------------------
            if (classe.Destructor()=:=unbound) {
                if (-](ets<-classe.membres,
                    TypeP(ETSVariable,ets),
                    ets.Tipus.TipusDelsElements().Destructor()!:=unbound)) {
                    // Crear el destructor dels camps
                    var ETSDestructor=ETSFuncio(TFDestructor,nom,classe,[],TVoid);
                    ETSDestructor.TeCos=true;
                    classe.Insertar(ETSDestructor);        
                }
            }
        }

    // <ElementClasse> =========================================================
    Rule <ElementClasse(classe:TClasse,nomRec)>::= 
        // Camp ----------------------------------------------------------------
        @var nom,t;
        identificador#(nom) 
        @classe.ComprovarDuplicat(nom);
        : <tipus(t,nomRec)> ";" 
        @classe.Insertar(ETSVariable(nom,t));        
        |
        // Funcio --------------------------------------------------------------
        @var nom,ClasseBase=classe,parametres,retorn;
        <PrototipusFuncio(nom,ClasseBase,parametres,retorn)> ";"
        @if (classe!:=ClasseBase) throw SemanticError("No se puede cambiar la clase a la que pertenece un m�todo");
        @var ets=ETSFuncio(TFFuncio,nom,ClasseBase,Parametres,retorn);
        @classe.ComprovarDuplicat(ets);
        @classe.Insertar(ets);        

        |
        // Procedure -----------------------------------------------------------
        @var nom,ClasseBase=classe,parametres;
        <PrototipusProcediment(nom,ClasseBase,parametres)> ";"
        @if (classe!:=ClasseBase) throw SemanticError("No se puede cambiar la clase a la que pertenece un m�todo");
        @var ets=ETSFuncio(TFProcediment,nom,ClasseBase,Parametres,TVoid);
        @classe.ComprovarDuplicat(ets);
        @classe.Insertar(ets);        
        
        | 
        // Constructor ---------------------------------------------------------
        @var nom,parametres;
        <PrototipusConstructor(nom,parametres)> ";"
        @if (TS.BuscarClasse(nom)!:=classe) throw SemanticError("No se puede cambiar la clase a la que pertenece un constructor");
        @var ets=ETSFuncio(TFConstructor,nom,classe,Parametres,TVoid);
        @classe.ComprovarDuplicat(ets);
        @classe.Insertar(ets);        

        |
        // Destructor ----------------------------------------------------------
        @var nom;
        <PrototipusDestructor(nom)> ";"
        @if (TS.BuscarClasse(nom)!:=classe) throw SemanticError("No se puede cambiar la clase a la que pertenece un destructor");
        @var ets=ETSFuncio(TFDestructor,nom,classe,[],TVoid);
        @classe.ComprovarDuplicat(ets);
        @classe.Insertar(ets);        

    // <PrototipusFuncio> ======================================================
    Rule <PrototipusFuncio(&nom,&ClasseBase,&parametres,&retorn)>::= 
        function identificador#(nom) 
        [
            @ClasseBase=TS.BuscarClasse(nom); 
            "::" identificador#(nom)
        ]
        <DecParametres(parametres)> ":" <Tipus(retorn,unbound)>
        
    // <PrototipusProcediment> =================================================
    Rule <PrototipusProcediment(&nom,&ClasseBase,&parametres)>::= 
        procedure 
        (
            identificador#(nom)
            [  
               @ClasseBase=TS.BuscarClasse(nom); 
               "::" 
               (
                   identificador#(nom) |
                   operator = @nom="operator=";
               )
            ]
            | 
            operator = @nom="operator=";
        )
        <DecParametres(parametres)>
                
    // <PrototipusConstructor> =================================================
    Rule <PrototipusConstructor(&nom,&parametres)>::= 
        Constructor identificador#(nom) 
        <DecParametres(parametres)>

    // <PrototipusDestructor> ==================================================
    Rule <PrototipusDestructor(&nom)>::= 
        Destructor identificador#(nom) 
        "(" ")"
        
    // <DecParametres> =========================================================
    Rule <DecParametres(&LlistaParametres)>::=
            @LlistaParametres=[];
            "(" [
                <DecParametre(LlistaParametres)>
                { , <DecParametre(LlistaParametres)> }
                ]")"
            @LlistaParametres=reverse(LlistaParametres);

    // <DecParametre> ==========================================================
    Rule <DecParametre(&ListaParametres)>::=
            //DeclaracionMultiplesParametros

            /*@var nom, t, referencia=false;
            [ & @referencia=true; ]
            identificador#(nom) 
            @if (-](p<-ListaParametres,p.nom==nom)) throw SemanticError("Parametre ",nom," duplicat");
            : <tipus(t,Unbound)>
			@if (!referencia) t.ComprovarConstruiblePerCopia();
            @ListaParametres=Parametre(nom,t,referencia)::ListaParametres;*/
            
            @var nom, t, referencia=false, noms = [], refs = [];
            [ & @referencia=true; ]
            identificador#(nom)
            @if (-](p<-ListaParametres,p.nom==nom)) throw SemanticError("Parametre ", nom, " duplicat");

            @noms=nom::noms;
            @refs=referencia::refs;
            
            [ {
                @var nom, t, referencia=false;
                , [ & @referencia=true; ]
                identificador#(nom)
                @if (-](p<-ListaParametres,p.nom==nom)) throw SemanticError("Parametre ", nom, " duplicat");
                @{
                    for (nomLlista<-noms) {
                        cout.println(nomLlista);
                        if (nomLlista == nom) throw SemanticError("Parametre ", nom, " duplicat");
                    }
                }
                @noms=nom::noms;
                @refs=referencia::refs;
            } ]

            : <tipus(t,Unbound)>
			@if (!referencia) t.ComprovarConstruiblePerCopia();
            @{
                noms = reverse(noms);
                refs = reverse(refs);
                for(i<-0..noms.length()-1) {
                    ListaParametres=Parametre(noms[i],t,refs[i])::ListaParametres;
                }
            }


    // <DecVar> =================================================================
    // DeclaracionVariableAuto
    /*Rule <DecVar>::= @var nom,t;
        Var identificador#(nom)
        @TS.ComprovarDuplicat(nom);
        : <tipus(t,Unbound)> 
        @var DescriptorsParametres=[];
        [<parametres(DescriptorsParametres)>]
        @t.ComprovarConstruible(DescriptorsParametres);
        @TS.Insertar(ETSVariable(nom,t));
        ";"*/

    //Var identificador (: <tipus> [ <parametres> ] | = (<Expressio> | <factor>) ) ";"

    Rule <DecVar>::= @var nom,t;
        Var identificador#(nom)
        @TS.ComprovarDuplicat(nom);
        (
            : <tipus(t,Unbound)> 
            @var DescriptorsParametres=[];
            [<parametres(DescriptorsParametres)>]
            @t.ComprovarConstruible(DescriptorsParametres);
            @TS.Insertar(ETSVariable(nom,t));
            
            |

            @var r = DescriptorValor();
			"=" <expressio(r, true)>
			@t = r.tipus;
            @TS.Insertar(ETSVariable(nom, t));
        )

        ";"

        
    // <DecFun> ================================================================
    Rule <DecFun>::= 
        @var nom, classe=TVoid, parametres, tipusRetorn;
        <PrototipusFuncio(nom,classe, parametres, tipusRetorn)>         
        @{
            var ets=ETSFuncio(TFFuncio,nom,classe,parametres,tipusRetorn);
            if (classe=:=TVoid) {
                TS.ComprovarDuplicat(ets);                
                TS.Insertar(ets);
            }
            else ets=classe.BuscarPrototipus(ets);
            if (ets.TeCos) throw SemanticError("Definici� de funci� duplicada");
            ets.TeCos=true;
            TS.NouAmbit(ets);
            for (p<-parametres) TS.Insertar(ETSVariable(p.nom,p.tipus));
        }
        <bloc>
        @TS.EliminarAmbit();

    // <DecProc> ===============================================================
    Rule <DecProc>::=
        @var nom, classe=TVoid, parametres;
        <PrototipusProcediment(nom,classe, parametres)>         
        @{
            var ets=ETSFuncio(TFProcediment,nom,classe,parametres,TVoid);
            if (classe=:=TVoid) {
                TS.ComprovarDuplicat(ets);
                TS.Insertar(ets);
            }
            else ets=classe.BuscarPrototipus(ets);
            if (ets.TeCos) throw SemanticError("Definici� de procediment duplicat");
            ets.TeCos=true;
            TS.NouAmbit(ets);
            for (p<-parametres) TS.Insertar(ETSVariable(p.nom,p.tipus));
        }
        <bloc>
        @TS.EliminarAmbit();
        
    // <DecConstructor> ========================================================
    Rule <DecConstructor>::= 
        @var nom, parametres;
        <PrototipusConstructor(nom,parametres)>         
        @{
            var ets=ETSFuncio(TFConstructor,nom,ts.BuscarClasse(nom),parametres,TVoid);
            ets=ets.classe.BuscarPrototipus(ets);
            if (ets.TeCos) throw SemanticError("Definici� de constructor duplicat");
            ets.TeCos=true;
            TS.NouAmbit(ets);
            for (p<-parametres) TS.Insertar(ETSVariable(p.nom,p.tipus));
        }
        <bloc>
        @TS.EliminarAmbit();
    
    // <DecDestructor> =========================================================
    Rule <DecDestructor>::=
        @var nom;
        <PrototipusDestructor(nom)>         
        @{
            var ets=ETSFuncio(TFDestructor,nom,ts.BuscarClasse(nom),[],TVoid);
            ets=ets.classe.BuscarPrototipus(ets);
            if (ets.TeCos) throw SemanticError("Definici� de destructor duplicat");
            ets.TeCos=true;
            TS.NouAmbit(ets);
        }
        <bloc>
        @TS.EliminarAmbit();

    // <bloc> ==================================================================
    Rule <bloc>::= 
    "{"
        @TS.NouAmbit();
        {
            <DecFun>
            | <DecProc>
            | <DecVar>
            | <instruccio>
        }
        @TS.EliminarAmbit();
    "}"

    // <instruccio> ============================================================
    Rule <instruccio>::=
        // Expressi� -----------------------------------------------------------
        @var dvRes=DescriptorValor();
        <Expressio(dvRes,false)> ";" 
        |
        // return --------------------------------------------------------------
        @var dvRes=DescriptorValor();
        return ( 
            <Expressio(dvRes,true)>
            @{
                if (!TipusPertany(dvRes.Tipus,ts.Funcio.TipusRetorn)) Throw SemanticError("Error de tipus a return");
                ts.Funcio.TipusRetorn.ComprovarConstruiblePerCopia();
            }

            | $ @if (ts.Funcio.TipusRetorn!:=TVoid) Throw SemanticError("Falta el valor de retorn a return");
            ) ";"
        |
        // if ------------------------------------------------------------------
        @var dvRes=DescriptorValor();
        if <Expressio(dvRes,true)> 
        @if (dvRes.Tipus!=TBool) throw SemanticError("Error de tipus en if");
        then <instruccio> [ else <instruccio> ]
        |
        // while ---------------------------------------------------------------
        @var dvRes=DescriptorValor();
        // afegit per afegir separador de bucle a la ts
        @ts.Pila=TSSeparadorBucle("start", "end")::ts.Pila;
        ///////
        while
            <Expressio(dvRes,true)>
            @if (dvRes.Tipus!=TBool) throw SemanticError("Error de tipus en while");
        do <instruccio>
        @TS.EliminarAmbit(); // afegit
        |
        // Print ---------------------------------------------------------------
        @var dvRes=DescriptorValor();
        (Print | PrintLn)
        [
            <Expressio(dvRes,true)>
            @switch (dvRes.Tipus) {
                TBool  => {};
                TChar  => {};
                TInt   => {};
                TReal  => {};
                TArray => {
                    if (dvRes.Tipus.TipusElements!:=TChar) {
                        throw SemanticError("Tipus de dades erroni a print");
                    }
                }
                TApuntador => {}
                Others => throw SemanticError("Tipus de dades erroni a print");
            };
            {,<Expressio(dvRes,true)>
                @switch (dvRes.Tipus) {
                    TBool  => {};
                    TChar  => {};
                    TInt   => {};
                    TReal  => {};
                    TArray => {
                        if (dvRes.Tipus.TipusElements!:=TChar) {
                            throw SemanticError("Tipus de dades erroni a print");
                        }
                    }
                    TApuntador => {};
                    Others => throw SemanticError("Tipus de dades erroni a print");
                };
            }
        ]
        ";"

        | 
        // Exit ----------------------------------------------------------------
        Exit ";"
        
        | 
        // delete --------------------------------------------------------------
        @var dvRes=DescriptorValor();
        delete <expressio(dvRes,true)> ";"
        @{
            if (!TypeP(TApuntador,dvRes.Tipus)) throw SemanticError("Tipus erroni a delete");
        }
        |
        // block { ...} --------------------------------------------------------
        <Bloc>

        |
        // ; -------------------------------------------------------------------
        ";"
        |
        // Imprimir taula de s�mbols -------------------------------------------
        IMPRIMIR_TAULA_DE_SIMBOLS ";" 
        @ts.Imprimir();
        @ts.ImprimirSemantic(SortidaSemantic);
        |
        // a partri d'aqui NOUS FETS PER MI
        // break ---------------------------------------------------------------
        //comprovar si esta dins de bucle o si esta dins de funcio
        @var pila = TS.Pila;
        @var dinsBucle = false;
        @while (pila!:=[]) {
            /*if (TypeP(TSSeparadorBucle, pila.head)) {
                throw SemanticError("Error semantic: break dins de funcio");
            }*/
            if (TypeP(TSSeparadorBucle, pila.head)) {
                dinsBucle = true;
                break;
            }
            pila=pila.Tail;
        };

        @if(!dinsBucle) throw SemanticError("Error semantic: break sense bucle");
        
        break
        ";"
        |
        // repeat --------------------------------------------------------------
        //repeat <instruccio> until <Expressio>
        @TS.Pila = TSSeparadorBucle("start", "end")::ts.Pila;
        @var dvRes = DescriptorValor();
        repeat <instruccio> until <Expressio(dvRes, true)>
        @if (dvRes.Tipus != TBool) throw SemanticError("Error de tipus de dades en repeat: condicio ha de ser Boolean");
        @TS.EliminarAmbit();
        ";"
        |
        // forto ---------------------------------------------------------------
        // for [var] identificador = <Expressio> to <Expressio> do <instruccio>
        @var hiHaVar = false;
        @var nom;
        @var dvRes1 = DescriptorValor();
        @var dvRes2 = DescriptorValor();
        @TS.Pila = TSSeparadorBucle("start", "end")::ts.Pila;
        
        for [var @hiHaVar = True;] 
        identificador#(nom)
        @{
            var ets;
            if (hiHaVar) {
                ets = ETSVariable(nom, TInt);
                TS.Insertar(ETSVariable(nom, TInt));
            } else {
                ets = TS.Buscar(nom);
                if (ets.Head.Tipus != TInt) throw SemanticError("Error de tipus de dades en for: variable ha de ser integer");
            }
        }

        = <Expressio(dvRes1,true)>
        @if (dvRes1.Tipus!=TInt) throw SemanticError("Error de tipus de dades en for: variable ha de ser integer");
        to <Expressio(dvRes2,true)>
        @if (dvRes2.Tipus!=TInt) throw SemanticError("Error de tipus de dades en for: variable ha de ser integer");
        do <instruccio>

        @TS.EliminarAmbit();


    // <Expressio> =============================================================
    Rule <Expressio(dvRes:DescriptorValor,Resultat:Bool)>::=
        <TerBool(dvRes,Resultat)> {
            "||" 
            @if (!Resultat) throw SemanticError("No s'aprofita el resultat");
            @if (dvRes.Tipus!:=TBool) throw SemanticError("Error de tipus de dades en || ",dvRes.Tipus);
            <TerBool(dvRes,true)>
            @if (dvRes.Tipus!:=TBool) throw SemanticError("Error de tipus de dades en || ",dvRes.Tipus);
            @dvRes.SetRValue(TBool);
        }
        @AssociarAtribut("Resultat=",Resultat);
        @dvRes.AssociarAtributs();

    // <TerBool> ===============================================================
    Rule <TerBool(dvRes:DescriptorValor,Resultat:Bool)>::=
        <FacBool(dvRes,Resultat)> {
            && 
            @if (!Resultat) throw SemanticError("No s'aprofita el resultat");
            @if (dvRes.Tipus!:=TBool) throw SemanticError("Error de tipus de dades en && ",dvRes.Tipus);
            <FacBool(dvRes,true)>
            @if (dvRes.Tipus!:=TBool) throw SemanticError("Error de tipus de dades en && ",dvRes.Tipus);
            @dvRes.SetRValue(TBool);
        }
        @AssociarAtribut("Resultat=",Resultat);
        @dvRes.AssociarAtributs();

    // <FacBool> ===============================================================
    Rule <FacBool(dvRes:DescriptorValor,Resultat:Bool)>::=
        <ExpArit(dvRes,Resultat)> [
            @if (!Resultat) throw SemanticError("No s'aprofita el resultat");
            @var dvRes2=DescriptorValor();
            (
                ==
                | !=
                | ">"
                | "<"
                | >=
                | <=
            )
            <ExpArit(dvRes2,true)>
            @switch ((dvRes.Tipus,dvRes2.Tipus)) {
                (TBool,TBool) => {}
                (TChar,TChar) => {}
                (TInt,TInt) => {}
                (TInt,TReal) => {}
                (TReal,TInt) => {}
                (TReal,TReal) => {}
                Others => {
                    if (TypeP(TApuntador,dvRes.Tipus) && TypeP(TApuntador,dvRes2.Tipus) && TipusIguals(dvRes.Tipus,dvRes2.Tipus)) {}
                    else throw SemanticError("Error de tipus de dades en comparacio ",(dvRes.Tipus,dvRes2.Tipus));
                }
            };
            @dvRes.SetRValue(TBool);
        ]
        @AssociarAtribut("Resultat=",Resultat);
        @dvRes.AssociarAtributs();

    // <ExpArit> ===============================================================
    Rule <ExpArit(dvRes:DescriptorValor,Resultat:Bool)>::=
        <terme(dvRes,Resultat)> {
            @if (!Resultat) throw SemanticError("No s'aprofita el resultat");
            @var dvRes2=DescriptorValor(); 
            (
                + <terme(dvRes2,true)>
                @switch ((dvRes.Tipus,dvRes2.Tipus)) {
                    (TInt,TInt) => dvRes.SetRValue(TInt);
                    (TInt,TReal) => dvRes.SetRValue(TReal);
                    (TReal,TInt) => dvRes.SetRValue(TReal);
                    (TReal,TReal) => dvRes.SetRValue(TReal);
                    Others => throw SemanticError(
                        "Error de tipus de dades en suma ",(dvRes.Tipus,dvRes2.Tipus));
                };
                | 
                - <terme(dvRes2,true)>
                @switch ((dvRes.Tipus,dvRes2.Tipus)) {
                    (TInt,TInt) => dvRes.SetRValue(TInt);
                    (TInt,TReal) => dvRes.SetRValue(TReal);
                    (TReal,TInt) => dvRes.SetRValue(TReal);
                    (TReal,TReal) => dvRes.SetRValue(TReal);
                    Others =>{
                        if (TypeP(TApuntador,dvRes.Tipus) && TypeP(TApuntador,dvRes2.Tipus)) dvRes.SetRValue(TInt);
                        else throw SemanticError("Error de tipus de dades en resta ",(dvRes.Tipus,dvRes2.Tipus));
                    }
                };
            )
        }
        @AssociarAtribut("Resultat=",Resultat);
        @dvRes.AssociarAtributs();

    // <Terme> =================================================================
    Rule <terme(dvRes:DescriptorValor,Resultat:Bool)>::=
        <potencia(dvRes,Resultat)> {
            @if (!Resultat) throw SemanticError("No s'aprofita el resultat");
            @Var dvRes2=DescriptorValor(); 
            (
                * <potencia(dvRes2,true)>
                @switch ((dvRes.Tipus,dvRes2.Tipus)) {
                    (TInt,TInt) => dvRes.SetRValue(TInt);
                    (TInt,TReal) => dvRes.SetRValue(TReal);
                    (TReal,TInt) => dvRes.SetRValue(TReal);
                    (TReal,TReal) => dvRes.SetRValue(TReal);
                    Others => throw SemanticError(
                        "Error de tipus de dades en resta ",(dvRes.Tipus,dvRes2.Tipus));
                };
                | / <potencia(dvRes2,true)>
                @switch ((dvRes.Tipus,dvRes2.Tipus)) {
                    (TInt,TInt) => dvRes.SetRValue(TReal);
                    (TInt,TReal) => dvRes.SetRValue(TReal);
                    (TReal,TInt) => dvRes.SetRValue(TReal);
                    (TReal,TReal) => dvRes.SetRValue(TReal);
                    Others => throw SemanticError(
                        "Error de tipus de dades en divisio ",(dvRes.Tipus,dvRes2.Tipus));
                };
            )
        }
        @AssociarAtribut("Resultat=",Resultat);
        @dvRes.AssociarAtributs();

    // <potencia> NOU =================================================================
    Rule <potencia(dvRes:DescriptorValor,Resultat:Bool)>::=
        //<factor> { ** <factor> }
        <factor(dvRes,Resultat)> {
            @if (!Resultat) throw SemanticError("No s'aprofita el resultat");
            @var dvRes2=DescriptorValor();
            (
                ** <factor(dvRes2,true)>
                @switch ((dvRes.Tipus,dvRes2.Tipus)) {
                    (TInt,TInt) => dvRes.SetRValue(TInt);
                    (TInt,TReal) => dvRes.SetRValue(TReal);
                    (TReal,TInt) => dvRes.SetRValue(TReal);
                    (TReal,TReal) => dvRes.SetRValue(TReal);
                    Others => throw SemanticError(
                        "Error de tipus de dades en potencia ",(dvRes.Tipus,dvRes2.Tipus));
                };
            )
        }
        @AssociarAtribut("Resultat=",Resultat);
        @dvRes.AssociarAtributs();



    // <Factor> ================================================================
    Rule <factor(dvRes:DescriptorValor,Resultat:Bool)>::=
        (
        // ! -------------------------------------------------------------------
        !
        @if (!Resultat) throw SemanticError("No s'aprofita el resultat");
        <factor(dvRes,true)>
        @if (dvRes.Tipus!:=TBool) throw SemanticError("Error de tipus de dades a !",dvRes.Tipus);
        @dvRes.SetRValue(TBool);
        | 
        // - -------------------------------------------------------------------
        -
        @if (!Resultat) throw SemanticError("No s'aprofita el resultat");
        <factor(dvRes,true)>
        @{
            switch (dvRes.Tipus) {
                TInt => {}
                TReal => {}
                Others => throw SemanticError(
                    "Error de tipus de dades a cambi de signe ",dvRes.Tipus);
            }
            dvRes.SetRValue(dvRes.Tipus);
        }
        | 
        // & -------------------------------------------------------------------
        &
        @if (!Resultat) throw SemanticError("No s'aprofita el resultat");
        <factor(dvRes,true)>
        @if (!dvRes.PermisEscriptura) throw SemanticError("El operando de & no es un LValue"); 
        @dvRes.SetRValue(TApuntador(dvRes.Tipus));
        |
        // ( expressi� ) ------------------------------------------------------
        "(" <Expressio(dvRes,Resultat)> ")"
        
        |
        // Numero -------------------------------------------------------------
        @var v;
        Numero#(v) 
        @if (!Resultat) throw SemanticError("No s'aprofita el resultat");
        @dvRes.SetRValue(if (typeP(int,v)) TInt else TReal);
        |
        // Caracter ------------------------------------------------------------
        @var v;
        Caracter#(v)
        @if (!Resultat) throw SemanticError("No s'aprofita el resultat");
        @dvRes.SetRValue(TChar);
        |
        // String --------------------------------------------------------------
        @var v;
        String#(v)
        @{
            if (!Resultat) throw SemanticError("No s'aprofita el resultat");
            dvRes.SetRValue(TArray(v.Length,TChar));
        }
        |
        // true ----------------------------------------------------------------
        true
        @if (!Resultat) throw SemanticError("No s'aprofita el resultat");
        @dvRes.SetRValue(TBool);
        |
        // false ---------------------------------------------------------------
        false
        @if (!Resultat) throw SemanticError("No s'aprofita el resultat");
        @dvRes.SetRValue(TBool);
        |
        // Null ----------------------------------------------------------------
        Null
        @if (!Resultat) throw SemanticError("No s'aprofita el resultat");
        @dvRes.SetRValue(TApuntador(TVoid));
        |
        // new -----------------------------------------------------------------
        "new" 
        @Var dvParametres=[],t;
        @if (!Resultat) throw SemanticError("No s'aprofita el resultat");
        <tipus(t,unbound)>  [<parametres(dvParametres)>]
        @{
            t.ComprovarConstruible(dvParametres);
            dvRes.SetRValue(TApuntador(t));
        }
        |        
        // this/Identificador -------------------------------------------------------
        <PosibleLValue(dvRes)> 
        (
            // Asignaci�n ------------------------------------------------------
            @if (!dvRes.PermisEscriptura) throw SemanticError("No es pot asignar");
            @var dvExp=DescriptorValor();        
            = <Expressio(dvExp,true)>
            @{
                Var tipusFont=dvExp.Tipus;
                Var tipusDesti=dvRes.Tipus;
                tipusDesti.ComprovarAssignable();
                if (!TipusPertany(tipusFont,tipusDesti)) throw SemanticError("Error de tipus de dades en =",(tipusFont,tipusDesti));
                dvRes.SetRValue(if (resultat) tipusFont else TVoid);
            }
        | 
            $ // Lectura
            @{
                if (Resultat && dvRes.Tipus=:=TVoid) throw SemanticError("Falta un resultat");
                if (!Resultat && dvRes.Tipus!:=TVoid) throw SemanticError("Sobra un resultat");
            }
        )
        )
        @AssociarAtribut("Resultat=",Resultat);
        @dvRes.AssociarAtributs();
        |
        // min -------------------------------------------------------
        //min "{" <Expressio> { ,  <Expressio> } "}"
        @var dvRes1 = DescriptorValor();
        @var dvRes2 = DescriptorValor();
        @var mesDeUn = false;

        min 
        "{" 
        <Expressio(dvRes1, true)> 
        { 
            ,  <Expressio(dvRes2, true)> 
            @if (dvRes1.Tipus != dvRes2.Tipus) throw SemanticError("Error de tipus en min: tots els operands han de ser del mateix tipus.");
            @mesDeUn = true;
        } 
        //@if (!mesDeUn) throw SemanticError("Error de tipus en min: ha d'haver-hi més de un operand.");
        "}"
        
        
        
    // <PosibleLValue> =========================================================
    // <PosibleLValue>::=::=(this|ID [<param>]) <Acces>
    Rule <PosibleLValue(dvAcc:DescriptorValor)>::=
    (
        @var nom;     
        (
            this
            @var ets=TS.BuscarMetodeActiu();
            @dvAcc.SetRValue(TApuntador(ets.Classe));
        |
            Identificador#(nom) 
            ( 
                // Crida o construcci�n ----------------------------------------
                @var etss=TS.Buscar(nom);
                @var dvParametres;
                <Parametres(dvParametres)>
                @{
                    if (TypeP(ETSTipus,etss.Head) && TypeP(TClasse,etss.Head.Tipus)) {
                        // Construcci�n
                        Var t=etss.Head.Tipus;                                    
                        var etsCons=SeleccionarMetode(t.Constructors(),dvParametres);
                        ComprovarPermisosParametres(dvParametres,etsCons.Parametres);
                        dvAcc.SetRValue(t);
                    }
                    else if (TypeP(ETSFuncio,etss.Head)) {
                        // Crida a funci�/procediment/m�tode
                        var etsFun=SeleccionarMetode(etss,dvParametres);
                        var t=etsFun.TipusRetorn;                                    
                        ComprovarPermisosParametres(dvParametres,etsFun.Parametres);
                        dvAcc.SetRValue(t);
                    }
                    else  throw SemanticError(nom," no es funci�, procedimient ni classe");
                }
                |
                
                // Variable/par�metre/Camp/Constant  ---------------------------
                $
                @{
                    var etss=TS.Buscar(nom);
                    var ets=etss.head;
                    if (TypeP(ETSVariable,ets)) {
                        dvAcc.SetLValue(ets.Tipus);
                    }
                    else throw SemanticError(nom," no es variable");
                }
            ) 
        )
        <Acces(dvAcc)>
    )
    @dvAcc.AssociarAtributs();
        
    // <Acces> =================================================================    
    Rule <Acces(dvAcc:DescriptorValor)>::= 
        {
            <AccesIndex(dvAcc)>      |
            <AccesCampMetode(dvAcc)> |
            <AccesApuntador(dvAcc)>
        }
        @dvAcc.AssociarAtributs();
        
    // <AccesIndex> =============================================================
    Rule <AccesIndex(dvAcc:DescriptorValor)>::= 
        @if (!typeP(TArray,dvAcc.Tipus)) throw SemanticError("Tipus erroni en array");
        @var dvIndex=DescriptorValor();
        "[" <Expressio(dvIndex,true)>
        @{
            if (dvIndex.Tipus!:=TInt) throw SemanticError("Tipus erroni en index");
            dvAcc.Tipus=dvAcc.Tipus.TipusElements;
        }
        "]"
        @dvAcc.AssociarAtributs();

    // <AccesCampMetode> =======================================================
    Rule <AccesCampMetode(dvAcc:DescriptorValor)>::= 
        @if (!typeP(TClasse,dvAcc.Tipus)) throw SemanticError("Tipus erroni en .camp ",typeof(dvAcc.Tipus));
        @var nom;
        . identificador#(nom) 
        (
            // .metode(...) ------------------------------------------------
            @if (!dvAcc.PermisEscriptura ) throw SemanticError("El objecte sobre el que s'aplica el m�todo no �s LValue");
            @var dvParametres;
            <parametres(dvParametres)>
            @{
                var etss=dvAcc.Tipus.BuscarMetode(nom);
                var ets=SeleccionarMetode(etss,dvParametres);
                ComprovarPermisosParametres(dvParametres,ets.Parametres);
                dvAcc.SetRValue(ets.TipusRetorn);
            }
            | 
            // .camp -------------------------------------------------------
            $
            @{
                var ets=dvAcc.Tipus.BuscarCamp(nom);
                dvAcc.Tipus=ets.Tipus;                  
            }
        )
        @dvAcc.AssociarAtributs();

    // <AccesApuntador> =======================================================
    Rule <AccesApuntador(dvAcc:DescriptorValor)>::= 
        ^
        @{
            if (!TypeP(TApuntador,dvAcc.Tipus)) throw SemanticError("Tipus erroni en ^");
            dvAcc.SetLValue(dvAcc.Tipus.TipusBase);
        }
        @dvAcc.AssociarAtributs();

    // <Parametres> ============================================================
    Rule <parametres(&dvParametres)>::=
        @dvParametres=[];
        "(" [
            @var dv=DescriptorValor();
            <Expressio(dv,true)>  
            @dvParametres=dv::dvParametres;
            { 
                @dv=DescriptorValor();
                , <Expressio(dv,true)> 
                @dvParametres=dv::dvParametres;
            } 
            ] 
        ")"
        @dvParametres=reverse(dvParametres);
    // =========================================================================
    END;    
    }
    CATCH (ex) {
        ParserErrorNLin=CSLGetScanLineNumber();
        ParserErrorLine=system$CSLScanLine();
        ParserErrorNCol=system$CSLGetScanCharNumber();
        ParserErrorException=ex;
        COut.PrintLn("Error a la linea ",ParserErrorNLin,
                     " del fitxer ",FileName);
        COut.PrintLn(ParserErrorLine);
        for (i<-0 .. min(ParserErrorNCol-1,ParserErrorLine.Length-1))
            COut.Print(if (ParserErrorLine[i]=:='\t') '\t'
                       else ' ');
        COut.PrintLN("^ ",if (TypeP(exception,ex)) ex.What else ex);
        if (TypeP(exception,ex)) COut.PrintLN(FmtPretty,ex.BackTrace);
        system$CSLSetParserLineNumber(OldNLin);
        system$CSLSetScanLineNumber(Oldline);
        if (!TypeP(Stream,ST)) Close(ScanInput);
        ScanInput=OldScanInput;
        return;
    };
    system$CSLSetParserLineNumber(OldNLin);
    system$CSLSetScanLineNumber(Oldline);
    if (!TypeP(Stream,ST)) Close(ScanInput);
    ScanInput=OldScanInput;
}
